#include <iostream>#include <vector>#include <iterator>#include <set>#include <string>template<class OBJ>inline void print_me(const OBJ& obj, const std::string& str = std::string()){    if(str.size() != 0)      std::cout << str << " = ";    std::cout << "[ "; for(typename OBJ::const_iterator it = obj.begin(); it != obj.end(); ++it)   std::cout << *it << " "; std::cout<<"]"<< std::endl;}class CCSPreparer{  public:  typedef std::size_t SizeType;  typedef std::set<SizeType> SetType;  typedef SetType::iterator SetIteratorType;  typedef std::vector<SizeType> VecIndexType;  typedef std::vector<SetType>VecSetType;      CCSPreparer(SizeType m, SizeType n, VecSetType& p):m_(m),n_(n),p_(p){}    /*! Fill rowindex (nnz), colPtrIt (n_+1) and mapperIt (nnz). After invocation, the last iterator contains the mapping from which the order of the sparse matrix values in compressed row style can be easily transferred to compressed column form later on.  */  template<class IT>  void create_CCS_format_data(IT rowIt, IT colPtrIt, IT mapperIt){        SizeType ct = 0,             dist,             entriesPerCol = 0,             nnz = 0,             numOfEmptyRows = 0,             numOfEmptyCols = 0,             nojfound = 0;           bool foundColEntryj = false;            for(int j = 0; j < n_; ++j){     //cols          ct = 0;            //std::cout << "entriesPerCol (bef. assignment) = "<< entriesPerCol << std::endl;           *colPtrIt = entriesPerCol;           foundColEntryj = false;                      nojfound = 0; //reset          for(int i = 0; i < m_; ++i){   //rows              if(j == 0){ //only once                if(p_[i].size() == 0)          		numOfEmptyRows++;  //empty row detected              }              for(SetIteratorType sit = p_[i].begin(); sit != p_[i].end(); ++sit){                                    if(*sit == j){                      dist = (int)std::distance(p_[i].begin(),sit);                              *rowIt = i;                   rowIt++;                              *mapperIt = ct + dist;                   mapperIt++;                  entriesPerCol++;                  foundColEntryj = true;                  break; //each entry only occurs once per set; no further search necessary                 }                 else{                    nojfound++;                 }              }              ct += p_[i].size();              if(j==0){  //only compute once                nnz += p_[i].size();                            if(nojfound == p_.size()){                   numOfEmptyCols++;                }              }          }          if(foundColEntryj) //otherwise a column is completely empty            colPtrIt++;      }            *(colPtrIt++)  = nnz; //number of nonzeros assigned           if(numOfEmptyRows != 0)        std::cout << "There were "<< numOfEmptyRows << " empty rows detected in sparsity pattern." << std::endl;        if(numOfEmptyCols != 0)        std::cout << "There were "<< numOfEmptyCols << " empty cols detected in sparsity pattern." << std::endl;     }     private:  SizeType m_, n_;  VecSetType& p_;    };using namespace std;int main(){   typedef CCSPreparer::VecSetType VecSetType;      typedef CCSPreparer::SetIteratorType SetIteratorType;   size_t m = 4,          n = 5,          nnz = 7;        VecSetType p(4);   p[0].insert(0); p[0].insert(3);   p[1].insert(2); p[1].insert(4);   p[2].insert(1);   p[3].insert(2); p[3].insert(4);      SetIteratorType sit;   cout << "p = " << endl;   for(int i = 0; i < m; ++i){      for(sit = p[i].begin(); sit != p[i].end(); ++sit){        cout << *sit << " ";     }     cout << endl;    }     typedef CCSPreparer::VecIndexType VecIndexType;  VecIndexType mapperC(nnz),rowC(nnz),colptrC(n+1);  CCSPreparer Prep(m,n,p);    Prep.create_CCS_format_data(rowC.begin(),colptrC.begin(),mapperC.begin());      cout << endl;   print_me(rowC,"row");   print_me(colptrC,"col_ptr");   print_me(mapperC, "mapper vec");      cout << endl << "TEST 2 -- empty col" <<endl;   m = 3;   n = 3;   nnz = 4;   VecSetType p1(m);   p1[0].insert(0);   p1[1].insert(0); p1[1].insert(1);   p1[2].insert(1);   cout << "p1 = " << endl;   for(int i = 0; i < m; ++i){      for(sit = p1[i].begin(); sit != p1[i].end(); ++sit){        cout << *sit << " ";     }     cout << endl;    }        //clear entries    mapperC.clear();    rowC.clear();    colptrC.clear();        CCSPreparer Prep1(m,n,p1);    mapperC.resize(nnz);    rowC.resize(nnz);    colptrC.resize(n+1);        Prep1.create_CCS_format_data(rowC.begin(),colptrC.begin(),mapperC.begin());      cout << endl;   print_me(rowC,"row");   print_me(colptrC,"col_ptr");   print_me(mapperC, "mapper vec");       cout << endl << "TEST 3 -- empty row" <<endl;   m = 4;    n = 4;    nnz = 6;      VecSetType p2(m);   p2[0].insert(1); p2[0].insert(3);   p2[2].insert(0); p2[2].insert(1); p2[2].insert(2);   p2[3].insert(1);   cout << "p2 = " << endl;   for(int i = 0; i < m; ++i){      for(sit = p2[i].begin(); sit != p2[i].end(); ++sit){        cout << *sit << " ";     }     cout << endl;    }       //clear entries    mapperC.clear();    rowC.clear();    colptrC.clear();        CCSPreparer Prep2(m,n,p2);    mapperC.resize(nnz);    rowC.resize(nnz);    colptrC.resize(n+1);        Prep2.create_CCS_format_data(rowC.begin(),colptrC.begin(),mapperC.begin());      cout << endl;   print_me(rowC,"row");   print_me(colptrC,"col_ptr");   print_me(mapperC, "mapper vec");         cout << endl << "TEST 4 " <<endl;   m = 4;   n = 2;   nnz = 5;      VecSetType p3(m);   p3[0].insert(0);   p3[1].insert(1);   p3[2].insert(0); p3[2].insert(1);   p3[3].insert(1);      cout << "p3 = " << endl;   for(int i = 0; i < m; ++i){      for(sit = p3[i].begin(); sit != p3[i].end(); ++sit){        cout << *sit << " ";     }     cout << endl;    }      //clear entries    mapperC.clear();    rowC.clear();    colptrC.clear();        CCSPreparer Prep3(m,n,p3);    mapperC.resize(nnz);    rowC.resize(nnz);    colptrC.resize(n+1);        Prep3.create_CCS_format_data(rowC.begin(),colptrC.begin(),mapperC.begin());      cout << endl;   print_me(rowC,"row");   print_me(colptrC,"col_ptr");   print_me(mapperC, "mapper vec");            cout << endl << "TEST 5 " <<endl;   m = 6;   n = 6;   nnz = 11;      VecSetType p4(m);   p4[0].insert(1);  p4[0].insert(3);  p4[0].insert(4);    p4[1].insert(1);  p4[1].insert(5);   p4[2].insert(3);    p4[3].insert(2);  p4[3].insert(4);   p4[4].insert(3);    p4[5].insert(0);  p4[5].insert(2);      cout << "p4 = " << endl;   for(int i = 0; i < m; ++i){      for(sit = p4[i].begin(); sit != p4[i].end(); ++sit){        cout << *sit << " ";     }     cout << endl;    }      //clear entries    mapperC.clear();    rowC.clear();    colptrC.clear();        CCSPreparer Prep4(m,n,p4);    mapperC.resize(nnz);    rowC.resize(nnz);    colptrC.resize(n+1);        Prep4.create_CCS_format_data(rowC.begin(),colptrC.begin(),mapperC.begin());      cout << endl;   print_me(rowC,"row");   print_me(colptrC,"col_ptr");   print_me(mapperC, "mapper vec");         cout << endl << "==================TEST 6 ====================" <<endl;   m = 5;   n = 4;   nnz = 7;    VecSetType p5(m);   p5[0].insert(0);  p5[0].insert(2);  p5[0].insert(3);       p5[2].insert(0); p5[2].insert(3);    p5[3].insert(3);     p5[4].insert(2);      cout << "p5 = " << endl;   for(int i = 0; i < m; ++i){      for(sit = p5[i].begin(); sit != p5[i].end(); ++sit){        cout << *sit << " ";     }     cout << endl;    }    //clear entries    mapperC.clear();    rowC.clear();    colptrC.clear();     CCSPreparer Prep5(m,n,p5);    mapperC.resize(nnz);    rowC.resize(nnz);    colptrC.resize(n+1);     Prep5.create_CCS_format_data(rowC.begin(),colptrC.begin(),mapperC.begin());    cout << endl;   print_me(rowC,"row");   print_me(colptrC,"col_ptr");   print_me(mapperC, "mapper vec");   return 0;}